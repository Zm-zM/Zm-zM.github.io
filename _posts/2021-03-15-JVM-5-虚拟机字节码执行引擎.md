---
layout:     post
title:      "JVM-虚拟机字节码执行引擎"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# 虚拟机字节码执行引擎

`虚拟机`是相对于`物理机`的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与操作引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。

## 运行时栈帧结构

栈帧（Stack Frame） 是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机中从入栈到出栈的过程。

在编译程序代码的时候，虚拟机需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入方法表的Code属性之中，**因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响**，仅仅取决于具体的虚拟机实现。

一个线程中的方法调用链可能很长，很多方法同时处于执行状态。对于执行引擎来说，在活动线程中，**只有位于栈顶的栈帧才是有效的**，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧操作。

### 局部变量表

局部变量表是一组变量值存储空间，用于存放**方法参数**和方法内部定义的**局部变量**。

局部变量表的容量以变量槽（Slot）为最小单位，虚拟机规范中没有明确规定Slot占用的单位大小，只是很有导向性地表示，每个Slot应当能够存放一个boolean、byte、char、short、int、float、reference或returnAddress类型地数据。它允许Slot的长度随着处理器、操作系统或虚拟机的不同而改变。

对于64位的数据类型（例如long和double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。

虚拟机使用索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量。如果访问的是32位数据类型，索引n就代表第n个Slot。如果是64位的数据类型，索引n就会**同时**使用n和n+1个Slot，**不允许以任何方式单独访问其中一个**。如果遇到这种情况，虚拟机就会在类加载的校验阶段抛出异常。

方法执行时，虚拟机是**使用局部变量表完成参数值到参数变量列表的传递过程的**。如果执行的是实例方法，那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用（即this），其余参数按照参数表顺序排列，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。

为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体定义的变量，其作用域不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。

### 操作数栈

操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（LIFO）的栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stack数据项中。32位的数据类型所占的栈容量为1，64位的数据类型所占的栈容量为2。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出/入栈操作。

在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时，就可以共用一部分数据，无需进行额外的参数复制传递。

<img src="E:\Java笔记\image\栈帧重叠.png" style="zoom: 67%;" />

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以指向方法的符号引用为参数。

这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为**静态解析。**

另外一部分将在每一次运行期间转化为直接引用，这部分称为**动态连接。**

### 方法返回地址

当一个方法开始执行后，只有两种方法可以退出这个方法。

第一种方法是执行引擎遇到任意一个方法返回的字节码指令，这种退出方法的方式称为**正常完成出口**。

另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体中得到处理。这种退出方法的方式称为**异常退出出口**。这种退出方式是不会给上层调用者产生任何返回值的。

无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上就相当于把当前栈帧出栈，因此退出可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

## 方法调用

方法调用并不等同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），在Class文件的编译过程并不涉及连接步骤，因此一切方法调用在Class文件中存储的都是符号引用，而不是方法在实际运行时内存布局的入口地址（即直接引用）。这个特性使得Java具有巨大动态扩展能力的同时，也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

### 解析

在类加载的过程中，会有一部分方法的符号引用会被转化为直接引用。这种解析的前提是：方法在程序调用之前就会一个可确定的调用版本。并且这个版本在运行期间是不可变的。也就是说，这种调用目标在代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为**解析**。

在Java语言中，符合`编译期可知，运行期不可知`这个要求的方法，主要包括静态方法和私有方法两大类。前者与类直接关联，后者在外部不可访问。

于此相关的是，在Java虚拟机中提供了5条方法调用字节码指令

- invokestatic：调用静态方法。
- invokespecial：调用实例构造器`<init>`方法、私有方法和父类方法。
- invokevirtual：调用所有的虚方法。
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的逻辑是由用户所设定的引导方法决定的。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本。它们在类加载的时候就会把符号引用解析为该方法的直接引用，称为非虚方法。与之相对应的其他方法都称为虚方法（final修饰的除外）。

虽然被final修饰的方法是使用invokevirtual指令调用的，但由于它无法被覆盖，也没有其他版本，因此在Java语言规范中明确说明了final方法是一种非虚方法。

### 分派

解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析期间就会把涉及的符号引用全部转变为直接引用。**而分派（Dispatch）调用则可能是静态的也可能是动态的**，根据分派的依据的**宗量数**可分为单分派和多分派。这两类分派方式的两两组合就构成了**静态单分派、静态多分派、动态单分派和动态多分派**。

```java
Human man = new Man();
```

我们把上面代码中的Human称为变量的静态变量（Static Type），或者叫做外观类型（Apparent Type）。而后面的Man称为实际类型（Actual Type）。静态类型和实际类型在程序中都可以发生变化，但区别在于，静态类型变化仅仅在使用时发生，而变量本身的静态类型不会变化，并且最终的静态类型在编译期就可以确定。而实际类型的变化要等到运行期才能确定，编译器在编译程序时并不知道一个变量的实际类型是上面。

```java
//实际类型变化
Human man = new Man();
man = new Woman();
//静态类型变化
sr.sayHello((Man)man);
sr.sayHello((Woman)man);
```

> 静态分派

虚拟机在方法重载时，是根据参数的静态类型而不是实际类型作为判定依据的。

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型代表是方法重载。

> 动态分派

动态分派和多态性的一个重要体现——重写（Override）有着紧密的关联。

从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：

- 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
- 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError`异常。
- 否则，按照继承关系从下往上依次对C的各个父类进行第2步搜索和验证
- 如果始终没有找到合适的方法，则抛出`java.lang.AbstracMethodError`异常。

由于invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中的invokevirtual指令将常量池的类方法符号引用解析到了不同的直接引用上。这个过程就是Java语言中方法重写的本质。

我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

> 单分派和多分派

方法的接收者与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派就是根据多余一个分派对目标方法进行选择。

现在为止，Java语言是一门静态多分派，动态单分派的语言。但随着Java语言的发展，可能会在未来支持动态多分派。

> 虚拟机动态分派的实现

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。

面对这种情况，最常用的“稳定优化”的手段就是建立一张**虚方法表**。使用虚方法表索引来代表元数据查找以提高性能。

虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的入口是一致的。如果子类重写了这个方法，那么就会转化为子类的这个方法的入口。

为了程序实现的方便，具有相同签名的方法，在子类和父类的虚方法表中应当具有一样的索引序号，这样当类型变化时，仅需要变更查找的方法表。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化后，虚拟机会把给类的方法表初始化完毕。

方法表是分派调用的“稳定优化”手段，实际上，在条件允许的情况下，虚拟机还会使用**内联缓存**和**基于“类型继承关系分析”技术的守护内联**这两种非稳定的“激进优化”。

## 基于栈的字节码解释执行引擎

Java语言经常被人们定位为“解释执行”的语言，但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。

...（编译原理）

### 基于栈的指令集与基于寄存器的指令集

Java编译器输出的指令流，基本上 一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集。

分别使用两种指令集计算“1+1”的结果，基于栈的指令集会是这样的：

```
iconst_1
iconst_1
iadd
istore_0
```

两条`iconst_1`指令连续把两个常量1压入栈，`iadd`指令把栈顶的两个值出栈，相加，然后把结果压入栈顶，最后，`istore_0`把栈顶的数据放入局部变量表的第0个Slot中

如果基于寄存器，那么程序会变成这个样子：

```
mov eax, 1
add eax, 1
```

`mov`指令将EAX寄存器的值设为1，然后`add`指令将这个寄存器的值加1，结果就保存在这个寄存器中。

基于栈的指令集的优点在于**可移植**。寄存器由硬件直接提供，程序直接依赖硬件寄存器不可避免要受到硬件的约束，不同架构体系的处理器提供的寄存器数量是不同的。如果使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机自行决定把一些使用频繁的数据放入寄存器中，以得到更好的性能，这样实现起来也更加简单一些。

栈架构的指令集还有其他一些优点，例如**代码更加紧凑**（字节码的每个字节代表一条指令，而多地址指令集中还需要存放参数），**编辑器实现更加简单**（不考虑空间分配的问题，空间都在栈上分配）。

虽然栈架构的指令集的代码非常紧凑，但完成相同功能的指令数量一般会比寄存器架构的多。更重要的是，栈实现在内存中，这就意味着会对内存进行频繁的访问。而对于处理器来说，内存始终是执行速度的瓶颈，这就导致了**栈架构的指令集的执行速度会相对较慢**。

