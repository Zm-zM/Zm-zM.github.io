---
layout:     post
title:      "计算机网络-传输层"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - 计算机网络
---

# 运输层

运输层协议为运行在不同主机上的应用程序之间提供了**逻辑通信**功能，从应用程序的角度看，通过逻辑通信，运行不同进程的主机好像直接相连一样。

**运输层协议是在端系统中而不是在路由器中实现的。**在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为**运输层报文段**。实现的方法是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文端。然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。

**运输协议能够提供的服务常常受制于底层网络协议的服务模型。**如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证，那么运输层协议也无法为进程之间发送的应用程序报文提供时延或带宽保证。

然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务，例如，即使底层网络层协议是不可靠的，运输协议也能为应用程序**提供可靠的数据传输服务**；即使网络层不能保证运输层报文段额机密性，运输协议也能使用**加密**来确保应用程序报文不被入侵者读取。

## 多路分解和多路复用

​	运输层报文段的首部字段中都会包含源端口号和目的端口号的信息，各占16比特（0~65535）。而每一个套接字（Socket）都有它唯一的标识。

在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解**。

在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为**多路复用**。

> 无连接的多路复用与多路分解

假定主机A中的一个进程具有UDP端口19157，它要发送一个应用程序数据块给位于主机B中的另一进程，该进程具有UDP端口46428。主机A中的运输层创建一个运输层报文段，其中包括应用程序数据、源端口号（19157）、目的端口号（46428）和两个其他值。网络层就将报文段封装成数据报，并尽力而为地将报文段交付给接收主机。如果该报文段到达接收主机B，接收主机运输层就检查该报文段中的目的端口号（46428），并将该报文段交付给端口号46428所标识的套接字。

一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。因此如果两个报文具有不同的源IP地址或/和源端口号，但是具有相同的目的IP和目的端口号，那么它们将通过相同的目的套接字被定位到相同的目的进程。

> 面向连接的多路复用和多路分解

TCP套接字和UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识的。因此，两个具有不同源IP地址或源端口号的到达TCP报文段将被定位到两个不同的套接字。

## 无连接运输：UDP

由 [ RFC 768 ] 定义的UDP只是做了运输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。

虽然TCP提供了可靠数据传输服务，但UDP依然有许多优势，主要有以下几点：

-  **关于发送什么数据以及何时发送的运用层控制更为精细。**采用UDP，只要应用程序将数据传递给UDP，UDP会将此数据打包进UDP并立即将其传递给网络层。而TCP可以由于拥塞控制等原因，数据传输会存在较大延迟。**因此UDP适合一些实时应用，仅要求满足最小的发送速率，不希望过分的延迟报文段的传送，且能容忍一些数据丢失。**
-  **无须连接建立。**UDP不会引入建立连接的时延，这可能是DNS运行在UDP之上而不是运行在TCP之上的主要原因。
-  **无连接状态。**TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不需要维护连接状态，也不跟踪这些数据。因此，某些专门用于某种特定应用的服务器当应用程序运行在UDP之上而不是运行在TCP上时，一般能支持更多的活跃用户。
-  **分组首部开销小。**每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。

### UDP报文段结构

UDP报文段首部只有4个字段，每个字段由两个字节组成。前两个字段是源端口号和目的端口号。后两个字段是长度和检验和。

长度字段指示了在UDP报文段中的字节数（首部加数据）。检验和用来检查在该报文段中是否出现了差错。

### UDP检验和

UDP检验和提供了差错检测功能。发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告。

## 可靠数据传输原理

可靠数据传输为上层实现的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失。而且所有数据都是按照其发送顺序进行交付。

实现这种服务抽象靠的是可靠数据传输协议。由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。例如TCP协议就是在不可靠的（IP）端到端网络层之上实现的可靠数据传输协议。

### 构造可靠数据传输协议

> 经完全可靠信道的可靠数据传输：rdt1.0

这种情况是最简单的，我们假设数据传输的信道是完全可靠的。只需要发送端接受上层调用，发送数据；接收端接收下层调用，接收数据即可。

> 经具有比特容错信道的可靠数据传播：rdt2.0

这种情况下，经过信道的分组中的比特可能受损，但不考虑丢失。

这是需要使用**自动重传请求协议（ARQ）**。在接收端接收消息后，根据消息的正确与否，发送肯定确认（ACK）或否定确认（NAK）。

ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况。

- 差错检测，需要接收方存在一种机制能够检测何时出现了比特差错
- 接收方反馈，让接收方提供明确的消息给发送方。例如用0代表NCK，1代表ACK
- 重传，当接收方收到有差错的分组时，发送方将重传该分组。

当发送方处于等待ACK或NAK的状态时，它不能从上层获取更多信息，也就是说，发送方不会发送一条新数据，直到其确认接收方已经正确接收当前分组。由于这样的行为，rdt2.0这样的协议称为**停等协议**。

虽然rdt2.0解决了比特受损的情况，但是还存在一个致命的缺陷，就是它**没有考虑到ACK或NCK分组受损的情况。**

解决这个问题的方法是，在数据分组中添加一个新字段，让发送方对其数据分组编号。对于停等协议来说，只需要1比特序号（1或0）就足够了。

> 经具有比特差错的丢包信道的可靠数据传输：rdt3.0

现在假定除了比特受损外，底层信道还会丢包。

当发送端发送的分组或者接收端发送的反馈分组出现丢失，发送端都不会接收到反馈信息。这是发送方需要设置一个等待时间，超时之后需要重传分组。

为了实现基于时间的重传机制，需要一个倒计时定时器。在一个给定的时间量过期后，可中断发送方。

### 流水线可靠数据传输协议

rdt3.0是一个功能正确的协议，但它的性能难以满足现今的高速网络环境，rdt3.0的性能问题的核心在于它是一个停等协议。

这种特殊的性能问题的一个简单解决方法是：不以停等方式运行，允许发送方发送多个分组而无需等待。

- 必须增加序号范围，因为每个输送中的分组（不包括重传）都需要有一个唯一的编号。
- 协议的发送方和接收方两端不得不缓存多个分组，发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方也许也需要缓存一些已正确接收的分组。

所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：**回退N步**和**选择重传**。

> 回退N步（GBN）

将序号分成4个返回，已被确认、已发送未确认、未发送、不可用。

已发送未确认和未发生的符号范围可以看成在序号范围为N的窗口。在窗口在协议运行过程中，不断向前滑动，N称为窗口长度。

GBN发送方必须响应以下三种类型的事件：

- 上层的调用。当上层调用发送方法时，GBN发送方首先检查发送窗口中，是否有N个已发送但未被确认的分组，如果窗口未满，则产生一个分组将其发送，并更新变量。如果窗口已满，则隐式的指示上层该窗口已满，实际上发送方更可能会缓存这些数据（并不立即发送）
- 收到一个ACK。在GBN协议中，对序号为n的分组采用累积确认的方式，表明接收方已正确接收到序号为n及n以前的所有分组。
- 超时事件。**如果出现超时，发送方将重传所有已发送但未被确认的分组**，如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器将被重新启动（刷新）。如果没有已发送未被确认的分组，计时器将被停止。

这种方法的优点在于接收缓存简单，接收方不需要缓存如何失序分组。虽然发送方必须维护窗口的上下边界以及nextseqnum（已发送未确认、未发送的间隔序号）在该窗口中的位置，但是接收方只需要维护下一个按序接收的分组的序号。

> 选择重传

GBN本身也有一些情况存在性能问题，尤其是窗口长度和带宽时延积都很大的时候。

**选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。**

SR发送方，将窗口中的分组依次发送，窗口中第一个分组被确认后，窗口将向前滑动一位。如果第一个分组一直未被确认或接收到NAK，则重传分组，窗口不动。

SR接收方将确认一个正确接收的分组而不管其是否按序，失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止。**在接收方接收了失序分组后，必须重新确认，发送ACK或NAK。**

窗口长度必须小于或等于序号空间大小的一半。

## 面向连接的运输：TCP

TCP被称为是**面向连接**的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程必须先相互“握手”，建立**逻辑连接**。

TCP连接提供的是**全双工服务**。由同一条TCP连接对接的进程A和进程B可以互相传输数据。TCP连接还是**点对点**的连接，对于一条TCP连接而言，只能是两台主机参与。  

<img src="E:\Java笔记\image\image-20200605143111570.png" alt="image-20200605143111570" style="zoom:67%;" />

从上图可以看出，TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一组缓存、变量和与进程连接的套接字。

### TCP报文端结构

TCP报文端由首部字段和一个数据字段组成。

<img src="E:\Java笔记\image\image-20200605144655315.png" alt="image-20200605144655315" style="zoom:50%;" />

与UDP类似，首部包含源端口号和目的端口号，用于多路分解和多路复用。同样还有检验和字段。

除此之外，TCP首部字段还包括以下：

- 32比特的序号字段和32比特的确认号字段。
- 16比特的接收窗口字段，该窗口用于流量控制。
- 4比特的首部长度字段，该字段表示以32比特为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。
- 可选与变长的选项字段。
- 6比特的标志字段
    - ACK比特用于指示确认字段中的值是有效的。
    - RST、SYN和FIN比特用于连接建立和拆除。
    - CWR和ECE比特，在明确拥塞通告中使用
    - PSH比特被直位时，就指示接收方应立即将数据交给上层。
    - URG比特用来指示报文里存在着发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段之处。

> 序号和确认号

TCP把数据看成一个无结构、有序的字节流。因此，一个报文段的**序号**是该报文段首字节的字节流编号。

主机A填充进报文段的**确认号**是主机A期望从主机B收到的下一字节的序号。

这里有一些有趣的情况：

假设主机A已收到一个来自主机B的包含字节0~535的报文段，以及另一个包含字节900~1000的报文段。由于某种原因，主机A还没有收到字节536~899的报文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536。因为**TCP只确认该流中至第一个丢失字节为止的字节**，所以TCP被称为**提供累积确认**。

主机A在收到第二个报文段之前，提前接收了第三个报文端，也就是说第三个报文段失序到达。那么如何处理失序到达的报文段呢？TCPRFC并没有为此明确规定任何规则，需要实现TCP的编程人员处理。

- 直接丢弃失序到达的报文段
- 保留失序的字节，并等待缺少的字节以填补该间隔

后一种选择对于网络带宽更加有利，是实践中采用的方法。

### 可靠数据传输

> 超时间隔加倍

每次TCP重传之后都会将计数器超时间隔加倍，直到定时器在收到上层应用数据和收到ACK任意一个时启动，才会恢复正常间隔时间。

超时间隔加倍可以缓解由于网络拥塞带来的频繁重传。

> 快速重传

超时触发重传存在的问题之一是**超时周期可能相对较长**。发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。**冗余ACK**就是再次确认某个报文段的ACK的响应，而发送方先前已经收到对该报文段的确认。

![image-20200605164226575](E:\Java笔记\image\image-20200605164226575.png)

发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，说明在这个已被确认过3次的报文段已经丢失。一旦收到3个冗余ACK，TCP就执行**快速重传**。



> 流量控制

TCP为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。

TCP通过让发送方维护一个称为接收窗口的变量来提供变量控制。接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连续两端的发送方都各自维护一个接收窗口。

- LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号
- LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号

由于TCP不允许已分配的缓存溢出，下式必须成立：

​																LastByteRcvd - LastByteRead ≤ RcvBuffer

接收窗口用rwnd表示，根据缓存可用空间的数量来设置

​																rwnd = RcvBuffer -  [LastByteRcvd - LastByteRead]

由于该空间‘是随着时间变化的，所以rwnd是动态的。

发送方轮流跟踪两个变量，LastByteSent和LastByteAcked，这两个变量之差LastByteSent - LastByteAcked，就是发送到连接中但未被确认的数据量，通过将未确认的数据量控制在值rwnd以内，就可以保证主机A不会使主机B的接收缓存溢出。因此发送方在整个连接生命周期中须保证：

​																LastByteSent - LastByteAcked ≤ rwnd

这个方案还存在一个小小的问题，如果主机B的rwnd为空了，发送消息给主机A，然后不再发送消息。即使主机B的缓存清空了，主机A也会一直处于阻塞状态，因为主机B没有将缓存清空的消息告诉它。为了解决这个问题，TCP规范中要求，当主机B的缓存窗口为0了，主机A继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认，当缓存开始清空了，确认报文中将会包含一个非0的rwnd值。

> TCP连接管理

三次握手的过程

- 第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含引用层数据，但是在报文段的首部中的一个标志位（即SYN比特）被置为1。另外客户会随机选择一个初始序号（client_isn + 1），并将此编号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。
- 第二步：一旦包含TCP SYN报文段的IP数据报达到服务器主机，服务器会从该数据报中提取出TCP SYN字段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段的确认号字段被置为client_isn + 1。最后，服务器选择自己的初始序号（server_isn），并将其放置到TCP报文段首部的序号字段中。
- 第三步：在收到上一步的报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。在这个阶段可以在报文段中携带客户到服务器的数据。

两次挥手

客户应用进程发出一个关闭连接命令。这会引起客户TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即FIN比特被设置为1。当服务器接收到该报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。最后客户对这个服务器的终止报文段进行确认。此时，两台主机上用于该连接的所有资源都被释放了。

<img src="E:\Java笔记\image\image-20200605205116785.png" alt="image-20200605205116785" style="zoom:50%;" />

## 拥塞控制原理

### 拥塞控制方法

我们可根据网络层是否为运输层拥塞控制提供了显式帮助，来区分拥塞控制方法。

- 端到端拥塞控制。在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持，即使网络中存在拥塞，端系统也必须通过网络行为的观察来推断之。
- 网络辅助的拥塞控制。在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。这种反馈可以简单地用一个比特来指示链路中地拥塞情况。

对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式，直接反馈信息可以由网络路由器发给发送方。更为通用的第二种形式的通知是，路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦接收到一个标记的分组后，接收方就会向发送方通知该网络拥塞。

## TCP拥塞控制

TCP使用的是端到端的拥塞控制，因为IP层是不能向端系统提供显式的网络拥塞返反馈。

TCP采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。

> 我们首先来分析一下，TCP发送方是如何限制向其连接发送流量的

TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成。运行在发送方的TCP拥塞控制机制追踪一个额外的变量，即拥塞窗口。拥塞窗口表示为cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。		

​															LastByteSent - LastByteAcked ≤ min {cwnd，rwnd}

上面的约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率。

> TCP发送方是如何感知在它与目的地之间的路径上出现了拥塞的

当出现过度的拥塞时，在沿着这条路径上的一台（或多台）路由器的缓存会溢出，引起一个数据报被丢弃，丢弃的数据报接着会引起发送方的丢包事件（要么超时，要么收到3个冗余ACK），发送方就认为在发送方到接收方的路径上出现了拥塞。

> TCP发送方如何确认一个合适的发送速率

**TCP拥塞控制算法**，该算法包括3个主要部分：①慢启动；②拥塞避免；③快速恢复。

慢启动和拥塞避免是TCP的强制部分，两者的差异在于对收到的ACK做出反应时增加cwnd长度的方式。快速恢复是推荐部分，对TCP发送方并非是必需的。

### 慢启动

当一个TCP连接开始时，cwnd的值通常初始置为一个MSS的较小值，每当传输的报文首次被确认就增加一个MSS，因此，TCP发送速率起始慢，但在慢启动阶段以指数增长。

何时结束这种指数增长呢？

当出现一个由超时指示的丢包事件时，TCP发送方将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2，并且将cwnd置为1并重新开始慢启动。

第二种方式与ssthresh的值有关，当指数增长达到ssthres值时，慢启动将会结束，进入拥塞避免模式。在拥塞避免模式下，TCP将会更加谨慎地增加cwnd。

最后一种结束慢启动的方式是，如果检测到3个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态。

<img src="E:\Java笔记\image\image-20200605220231337.png" alt="image-20200605220231337" style="zoom:50%;" />

### 拥塞避免

一旦进入拥塞避免，cwnd的值大约是上次遇到拥塞的一半。每个RTT只将cwnd的值增加一个MSS。一种通用的方式是，对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS（MSS/cwnd）字节。

当遇到超时事件引发的丢包时，还会像上节一样，将cwnd设置为1，并将ssthres设置为cwnd的一半。

当检测到3个冗余ACK时，就会进入快速恢复状态

### 快速恢复

在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的最后一个ACK到达时，TCP在降低cwnd后进入拥塞避免模式。如果出现超时现象，快速恢复就会执行如同慢启动和拥塞避免中一样的动作，将cwnd置为1，将ssthres置为cwnd的一半。



