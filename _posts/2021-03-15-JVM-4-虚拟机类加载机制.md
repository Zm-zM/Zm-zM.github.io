---
layout:     post
title:      "JVM-虚拟机类加载机制"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# 虚拟机类加载机制

虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

在Java语言里，类型的加载、连接和初始化都是在**程序运行期间**完成的。Java被称为天生可以动态扩展的语言，就是由于它有着**运行期动态加载**和**动态连接**的特点。

## 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：

加载、验证、准备、解析、初始化、使用和卸载7个阶段。

其中，验证、准备和解析统称为连接。

加载、验证、准备、初始化、卸载。这5个阶段的开始顺序（但不一定会等前一个阶段结束，才开始下一阶段，可能在上一阶段执行过程中就激活了下一阶段的开始）是确定的，但是解析则不同，在某些情况下，它可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称动态绑定或晚期绑定）。

什么情况下开始类加载过程的第一阶段：加载，Java虚拟机没有强制规定。但是对于初始化阶段，Java虚拟机规范严格规定了**有且仅有**5种情况必须立即对类进行“初始化”

- 遇到new、getstatic、putstatic或invokestatic这4条字节码时
    - 使用new关键字实例化对象时
    - 获取一个类的静态字段
    - 设置一个类的静态字段（被final修饰过，编译期已放入常量池的除外）
    - 调用一个类的静态方法

- 使用java.lang.reflect包的方法对类进行反射调用的时候。
- 当初始化一个类时，如果其父类还没有进行初始化时，需要先触发其父类的初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法），虚拟机会初始化那个类。
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄对于的类没有进行过初始化的时候。

接口的加载过程与类的加载过程稍有不同，接口与类真正有所区别的是，上述第三条。一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候（比如引用接口中定义的常量）才会初始化。

## 类加载的过程

也就是加载、验证、准备、解析和初始化这5个过程

### 加载

在加载过程，虚拟机主要完成以下3件事情

- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。

这里，虚拟机根本没有指明从哪里获取类的二进制字节流，这就带来高度的灵活性。开发人员可以从ZIP等压缩文件、网络中、运行时计算生成等等方式获取。

加载阶段和连接阶段的部分内容是交叉进行的，但开始时间依然保持着固定的顺序。

### 验证

这一阶段的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

Java语言是相对安全的语言，但Class文件并不一定是由Java语言编译而来的，从字节码语言层面上，是可以构造出有害的字节流文件的，如果不对这些字节流文件进行验证，很可能会因此导致虚拟机的崩溃。

从整体上来看，验证阶段大致上会完成下面4个阶段的检验动作

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

对于虚拟机的类加载机制来说，验证阶段是一个非常重要，但不一定是必须的。如果所运行的代码已经被反复使用和验证过，那么可以考虑使用`-Xverify:none`参数来关闭大部分类的验证措施，以缩短虚拟机类加载时间。

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中进行分配。此时仅进行的是类变量（static修饰的），而不包含实例变量。

通常情况下，类变量会被初始化为零值。但如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue指定的值。

例如`final`修饰的类变量。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

> 符号引用

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中

> 直接引用

直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标一定存在于内存中。

------

虚拟机规范并**未规定解析阶段发送的具体时间**，只要求在执行特定的16个指令之前，将它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

对同一个符号引用进行多次解析请求是很常见的事情，出invokedynamic指令以外，虚拟机可以实现对第一次解析结果进行缓存，从而避免解析动作重复进行。

**对于invokedynamic指令，上述规则不成立。**当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持，它对应的引用称为**“动态调用点限定符”**，这里“动态”的含义就是必须等到程序运行到这条指令时，解析动作才能开始。

解析动作主要针对，类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

> 类或接口的解析

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，需要经过以下3个步骤

- 如果C不是一个数组类型，那么虚拟机会把代表N的全限定类名传递给D的类加载器去加载这个类C。在这个过程中，由于元数据验证或字节码验证的需要，又可能会触发其他相关类的加载动作。
- 如果C是一个数组类型，那么虚拟机将会按照第一点的规则先加载数组元素类型，然后由虚拟机生成一个代表此数组维度和元素的数组对象。
- 如果上述步骤没有发生异常，此时C在虚拟机中已经成为一个有效的类或接口了。但在解析完成之前，还需要进行符号引用验证，确认D对C的访问权限。如果D不具备这样的权限，就会抛出`java.lang.IllegalAccessError`异常。

> 字段解析

要解析一个从未被解析过的字段符号引用，首先会对字段所属的类或接口的符号引用进行解析。如果这个解析过程成功，我们将这个类或接口用C表示。虚拟机规范要求将会按照如下步骤进行解析

- 如果C本身就含有简单名称和字段描述符都与目标相匹配的字段，直接返回该字段的直接引用。
- 否则，如果C实现了接口，就会从上到下按照继承关系搜索各个接口和它们的父接口。
- 否则，如果C不是`java.lang.Object`类，就会根据继承关系搜索其父类
- 否则，查找失败，抛出`java.lang.NoSuchFieldError`异常。

如果查找成功返回了直接引用，就会对该字段进行权限验证，如果不具备对该字段的权限，就会抛出`java.lang.IllegalAccessError`异常。

> 类方法解析

要解析一个从未被解析过的类方法符号引用，首先会对字段所属的类或接口的符号引用进行解析。如果这个解析过程成功，我们将这个类用C表示。

- 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是接口，就会直接抛出`java.lang.IncompatibleClassChangeError`异常。
- 如果通过上一步，就在C中查找是否有简单名称和方法描述符都与目标匹配的方法。
- 否则，在类C的父类中，按照继承关系继续查找
- 否则，在类C实现的接口列表和它们的父接口中查找，如果存在匹配的方法，说明类C是一个抽象类，抛出`java.lang.AbstractMethodError`。
- 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`。

如果查找成功返回了直接引用，就会对该方法进行权限验证，如果不具备对该方法的权限，就会抛出`java.lang.IllegalAccessError`异常。

> 接口方法解析

要解析一个从未被解析过的接口方法符号引用，首先会对字段所属的类或接口的符号引用进行解析。如果这个解析过程成功，我们将这个接口用C表示。

- 如果在接口方法表中发现class_index中索引的C是类，就会直接抛出`java.lang.IncompatibleClassChangeError`异常。
- 否则，在接口C中查找是否有简单名称和方法描述符都与目标匹配的方法。
- 否则，在父接口中递归查找，直到`java.lang.Object`类为止
- 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`异常。

因为接口中的方法默认都是public，所以不会存在访问权限的问题。

### 初始化

类初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正开始执行类中定义的Java代码。

在准备阶段，变量已经赋过一次系统要求的初始值，而初始化阶段，则根据执行类构造器`<client>()`方法，进行初始化。

对于`<client>()`方法，有以下几点需要说明

- `<client>()`方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并而成的。收集的顺序与源文件中语句出现的顺序一致，静态语句块只能访问到其之前的变量，在它**之后的变量**可以赋值，但是不能访问。
- `<client>()`与实例构造器不同，不需要显式的调用父类构造器。虚拟机会保证子类的`<client>()`方法执行之前，父类的`<client>()`方法已经执行完毕。
- `<client>()`方法对于类和接口并不是必须的，如果类或接口中没有对类变量的赋值语句，也没有静态代码块。虚拟机将不会生成`<client>()`方法。
- 接口中不能使用静态代码块，但仍有变量初始化赋值操作，虚拟机依然会生成`<client>()`方法。但和类不同的是，接口初始化时，不一定需要先初始化父接口的`<client>()`方法，只有父接口中定义的变量使用时，才会初始化。接口的实现类在初始化时，也不会初始化接口的`<client>()`方法。
- 虚拟机会保证类的`<client>()`方法在多线程环境下，被正确的加锁、同步。

## 类加载器

虚拟机设计团队把类加载阶段中的**“通过一个类的全限定名来获取描述此类的二进制字节流”**这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为**“类加载器”**。

### 类与类加载器

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用并不仅仅局限于类加载阶段。对于任何一个类，都需要加载它的类加载器和这个类本身一同确立在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

即使两个类来源于同一个Class文件，被同一个虚拟机加载，**只要加载它们的类加载器不同，那么这两个类就必定不相等。**这里所指的“相等”，包括代表类的Class对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法的返回结果，也包括使用`instanceof`关键字做对象所属关系判定等情况。

### 双亲委派模型

对于Java虚拟机来说，只存在两种类加载器，一种是C++实现的**启动类加载器**，属于Java虚拟机的一部分；另外一种是**所有其他的类加载器**，这些类加载器由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类`java.lang.ClassLoader`。

从开发人员来看，类加载器还可以分得更加细致一些。

- 启动类加载器，这个类加载器负责将存放在`<JAVA_HOME>/lib`目录下的，或者被`-Xbootclasspath`参数所指定的路径的，并且是虚拟机识别的（仅仅按照文件名识别）类库加载到虚拟机中。启动类加载器无法被Java程序直接引用。
- 扩展类加载器，它负责加载`<JAVA_HOME>\lib\ext`目录中的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器，这个类加载器是`getSystemClassLoader()`方法的返回值，一般也称为系统类加载器。它负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序没有自定义自己的类加载器，一般情况下，这个就是程序默认的类加载器。

双亲委派模型，要求除了顶层的启动类加载器外，其余的类加载器都应当由自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系实现，而是使用组合关系来复用父加载器的代码。

双亲委派模型的**工作过程**是，如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，二手把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，最终会传送到顶层的启动类加载器，只有父类加载器反馈自己无法完成这个请求时（它的搜索范围内没有这个类），子类加载器才会尝试自己加载。

双亲委派模型的好处是，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类`java.lang.Object`类，无论哪一个类加载器要加载它，最终都会由委派到顶层的启动类加载器去加载它。如果没有这个模型，那么系统中可能就会出现多个不同的Object类（由不同类加载器加载产生）。

### 破坏双亲委派模型

......

