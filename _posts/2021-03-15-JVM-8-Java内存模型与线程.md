---
layout:     post
title:      "JVM-Java内存模型与线程"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# Java内存模型与线程

Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

## Java内存模型

### 主内存和工作内存

Java内存模型的主要目标是定义各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

Java内存模型规定了所有的变量都存储在主内存中，每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

### volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。

当一个变量定义为volatile后，它将具备两种特性，第一是**保证此变量对所有线程的可见性**，这里的可见性是指，当一个线程修改了这个变量的值，新值对于其他线程是立即可知的，而不是像普通变量先传递到主内存，其他线程从主内存中读取新值。

由于Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。由于volatile变量只能保证可见性，在不符合以下 两条规则的运算场景中，我们仍然要通过加锁来保证原子性

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
- 变量不需要与其他的状态变量共同参与不变约束

使用volatile变量的第二个语义是**禁止指令重排序优化**。

### 先行发生原则

先行发生是Java内存模型中定义的两项操作之间的偏序关系。

Java内存模型中包含以下“天然的”先行发生关系。

- 程序次序规则，在一个线程中，按照控制流顺序，前面的操作先于后面的操作。
- 管程锁定规则，一个unlock操作先行发生于后面对同一个锁的lock操作。
- volatile变量规则，对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
- 线程启动规则，Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终止规则，线程中的所有操作都先行发生于对此线程的终止检测。
- 线程中断规则，对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
- 对象终结规则，一个对象的初始化完成先行发生于它的finalize()方法的开始
- 传递性，如果操作A先行操作B，操作B先行操作C，那么操作A先行操作C

## Java与线程

### 线程的实现

线程是比进程更轻量级的调度执行单位，各个线程可以共享进程资源（内存地址，文件I/O等），又可以独立调度。

实现线程主要有3种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。

> 使用内核线程实现

内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级线程。每个轻量级线程都由一个内核线程支持。由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：

- 由于轻量级线程是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用，而系统调用的代价相对较高，需要从用户态和内核态来回切换。
- 每个轻量级线程都需要有一个内核线程的支持，因此轻量级进程都消耗一定的内核资源，因此一个系统支持轻量级进程的数量是有限的。

> 使用用户线程实现

用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的创建、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种线程不需要切换到内核态，因此操作是非常快且低消耗的。

使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有线程操作都需要用户程序自己处理。

> 使用用户进程加轻量级进程混合实现

用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。

### Java线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种。分别是协同式线程调度和抢占式线程调度。

