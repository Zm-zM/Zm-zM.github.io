---
layout:     post
title:      "JVM-早期（编译期）优化"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# 早期（编译期）优化

Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器把`*.java`文件转变成`*.class`文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器），把字节码转变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器）直接把`*.java`文件编译成本地机器代码的过程。

在本章的编译器和编译期，均指的是第一类编译过程。

第一类编译器（例如Javac），对代码的运行效率几乎没有任何优化措施。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样就可以让那些不是由Javac产生的Class文件也能够同样享受到编译器优化带来的好处。

但是Javac做了很多针对于Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。

可以说，Java中即时编译器在运行期的优化过程对于**程序运行**来说更重要，而前端编译器在编译期的优化过程对于**程序编码**来说关系更加密切。

## Javac编译器

### 解析和填充符号表

> 词法、语法分析

解析步骤包括了经典程序编译原理中的词法分析和语法分析。

**词法分析**是将源代码的字符流转变为标记（Token）集合，标记是编译过程的最小集合。

```java
int a = b + 2;//int, a, =, b, +, 2 分别是一种标记
```

**语法分析**是根据Token序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法数的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。

经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续操作都建立在抽象语法树上。

> 填充符号表

完成了语法分析和词法分析之后，下一步就是填充符号表的过程。

符号表是由一组符号地址和符号信息构成的表格。符号表中登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（检查一个名字的使用和之前的说明是否相同）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

### 注解处理器

在Java1.5以后，Java语言提供了对注解的支持，这些注解与普通Java代码一样，是在**运行期间**发挥作用的。在JDK1.6中实现了JSR-269（插入式注解处理API）规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。**如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。**

### 语义分析和字节码生成

语法分析能够表示一个结构正确的源程序的抽象，但是无法保证源程序是符合逻辑的。而语义分析的主要任务是**对结构上正确的源程序进行上下文有关性质的审查**。

> 标注检查

标注检查步骤检查的内容包括诸如**变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配**等。在标注检查过程中有一个重要的步骤是**常量折叠**。例如

```java
int a = 1 + 2;
```

经过常量折叠之后，它们将会被折叠为字面量“3”。由于编译期进行了常量折叠，所以代码中定义为`a = 1 + 2`和`a = 3`，在运行期间没有任何区别。

> 数据与控制流分析

数据与控制流分析检查的内容包括程序局部变量在使用前是否由赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。

> 解语法糖

语法糖，也称糖衣语法。指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，能够添加程序的可读性，从而减少程序代码出错的机会。

Java在现代编程语言中属于“低糖语言”。Java中最常用的语法糖主要是前面提到的泛型、变长参数、自动装箱/拆箱等。虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。

> 字节码生成

字节码生成是Javac编译过程的最后一步。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。

例如，实例构造器`<init>`和类构造器`<clinit>`方法就是在这个阶段添加入语法树中的（这里的实例构造器并不是指默认的构造器，默认的构造函数在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程。

除了生成构造器以外，还有其他一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append()操作。

## Java语法糖

语法糖，也称糖衣语法。指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，能够添加程序的可读性，从而减少程序代码出错的机会。

### 泛型与类型擦除

泛型的本质是参数化类型的应用。也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。

泛型技术在C#和Java之中的使用方法看似相同，但实现上却有着根本性的分歧。C#里面的泛型无论在程序源码、编译后的IL（中间语言）中，或是运行期的CLR中，都是切实存在的。`List<int>`和`List<String>`就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为**真实泛型**。

Java语言的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了。并且在相应的地方插入了强制转型代码。因此，对于运行期的Java语言来说，`ArrayList<int>`和`ArrayList<String>`就是同一个类。所以泛型技术实际上是Java语言的一颗语法糖，Java语言中泛型的实现方法称为泛型擦除，基于这种方法实现的泛型称为伪泛型。

擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。

### 自动装/拆箱与遍历循环

自动装/拆箱在编译之后被转化成了对应的包装和还原方法，而遍历循环则把代码还原成了迭代器的实现，变长参数在调用的时候变成了一个数组类型的参数。

### 条件编译

C、C++的预处理器最初的任务是解决编译时的代码依赖关系（例如#include预处理命令），而Java语言中并没有使用预处理器，因为Java语言天然的编译方式（将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）无需使用预处理器。

Java语言使用条件编译的方法是，使用条件为常量的if语句。

