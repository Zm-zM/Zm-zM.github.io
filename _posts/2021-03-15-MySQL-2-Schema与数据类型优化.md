---
layout:     post
title:      "MySQL-Schema与数据类型优化"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - MySQL
---

# 选择优化的数据类型

MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。

- **更小的通常更好**
    - 一般情况下，应该尽量使用可以正确存储数据的最小数据类型，但是要确保没有低估需要存储的值的范围。
- **简单就好**
    - 简单数据类型的操作通常需要更少的CPU周期。
- **尽量避免NULL值**
    - 通常情况下，最好指定列为NOT NULL，除非真的需要存储NULL值。
    - 如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引
    - 计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。

## 整数类型

如果存储整数，可以使用的数据类型有以下几种：

- TINYINT，8位
- SMALLINT，16位
- MEDIUMINT，24位
- INT，32位
- BIGINT，64位

整数类型有可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。

## 实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。 

- FLOAT，4字节
- DOUBLE，8字节

因为计算需要额外的空间和计算开销，所以尽量只在对小数进行精确计算时，才使用DECIMAL——例如存储财务数据。

## 字符串类型

VARCHAR和CHAR是两种最主要的字符串类型。

### VARCHAR

VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，VARCHAR需要使用1或2个字节来记录字符串的长度。

但是，由于行是变长的的，在UPDATE时可能使行变得比原来更长，这就需要做额外的工作。

下面这些情况使用VARCHAR是合适的：

- 字符串列的最大长度比平均长度大很多
- 列的更新很少
- 使用了像UTF-8这样复杂的字符集

### CHAR

CHAR类型是定长的，当存储CHAR值时，MySQL会删除所有的末尾空格。

CHAR类型适合存储很短的字符串（不需要额外记录字符串长度的开销），或者所有值都接近同一个长度。以及需要经常变更的数据（定长的CHAR类型不容易产生碎片）。

### BLOB和TEXT类型

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制的字符方式存储。

它们属于不同的数据类型家族。前者是二进制类型，后者是字符类型。

与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。当BLOB和TEXT太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储实际的值。

BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。

MySQL只对BLOG和TEXT列的最前`max_sort_length`字节进行排序。也不能将列全部长度的字节进行索引。

## 日期和时间类型

MySQL能存储的最小时间粒度为秒。但是MySQL也可以使用微秒级的粒度进行临时运算。

### DATETIME

这个类型能保存大范围的值，从1001年到9999年，精度为秒。

它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节的存储空间。

### TIMESTAMP

TIMESTAMP类型保存了从1970年1月1日午夜以来的秒数，只使用4个字节，只能表示1970年到2038年。

TIMESTAMP显示的值依赖于时区，MySQL服务器，操作系统以及客户端连接都有时区设置。

------

除了特殊行为以外，通常也应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。

如果需要存储比秒更小的日期和时间值，可以使用**BIGINT存类型存储微秒级别的时间戳，或者使用DOUBLE存储秒之后的小数部分。**

## 位数据类型

### **BIT**

可以使用BIT列在一列中存储一个或多个TURE/FALSE值，BIT(1)定义一个包含单个位的字段，依次类推，BIT位的最大长度是64位。

BIT的行为随引擎而异，MyISAM会打包存储所有的BIT列，所以17个单独的BIT列只需要17个位存储，其他存储引擎例如InnoDB或Memory，为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。

MySQL把BIT作为字符串类型而不是数字类型。在数字上下文场景中检索时，会将位字符串转换成数字，例如存储一个b'00111001'，在检索它时会得到ASCII码为'57'的数字'9'。但是在数字上下文场景中，得到的是数字57。

### SET

在MySQL内部，SET数据类型是以一系列打包的位的集合来表示的，这样就可以有效利用了存储空间。主要缺点是改变列的定义的代价较高，需要ALTER TABLE，一般来说在SET列上也无法通过索引查找。

一种替代SET的方式是使用一个整数包装一系列的位。例如可以把8个位包装到一个TINYINT中，并且按位操作来使用。