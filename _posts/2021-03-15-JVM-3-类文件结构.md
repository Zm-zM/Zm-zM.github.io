---
layout:     post
title:      "JVM-类文件结构"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# 类文件结构

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编译语言发展的一大步。

直到现在，计算机依然只能识别0和1。但虚拟机以及大量建立在虚拟机基础上的程序语言如雨后春笋般出现并蓬勃发展。将代码编译成二进制本地机器码已不再是唯一的选择，越来越多的语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

实现语言无关性（在Java虚拟机上运行的字节码不一定是Java语言编译而来）的基础是虚拟机和字节码存储格式。Java虚拟机不和包括Java语言在内的任何语言绑定，它只与`Class文件`这种特定的二进制文件格式所关联。Java虚拟机对`Class文件`有很多强制性的语法和结构化约束，但任何一门功能性语言都可以表示成这样的Class文件。虚拟机并不关心`Class文件`来源于什么语言。

## Class类文件的结构

Class文件是一组以8位字节位基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符。当遇到需要占用8位字节以上空间地数据项时，则会按照**高位在前**的方式分割成若干个8位字节存储。

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据结构：无符号数和表。

> 无符号数

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

> 表

表是由多个无符号数或者其他表作为数据项构成的复合数据类型。所有表都习惯性地以`_info`结尾。表用于描述有层次关系的复合结构的数据。整个Class文件本质上就是一张表。

无论是无符号数还是表，当需要描述同一类型但数量不多的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称一系列连续的某一类型的数据为**某一类型的组合**。

### 魔数与Class文件的版本

每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准都是用魔数来进行身份识别，譬如图片格式。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意的改动。

Class文件的魔数很有“浪漫气息”，值为`0xCAFEBABY`。

紧接着魔数的4个字节存储的是Class文件的版本号，第5和第6个字节是次版本号，第7和第8个字节是主版本号。Java的版本号是从45开始的，从Java1.1开始的每一个JDK大版本更新发布，都会在主版本号上加1。

### 常量池

紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库。

常量池中常量的数据是不固定的，因此在常量池的入口需要防止一个u2类型的数据，代表常量池容量计数值。这个容量计数是**从1而不是0开始的**。十六进制数`0x0016`，即十进制的22，代表常量池中有21项常量。

从1开始的原因是，0是由特殊含义的，某些指向常量池的索引值数据在特定情况下需要表达“不引用任何一个常量池项目”的含义。

常量池中主要存放两大类常量，字面量和符号引用。

字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。

而符号引用则属于编译原理方面的概念，包括了下面三类常量

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

常量池中的每一项常量都是一个表。JDK1.7中共有14中结构各不相同的表结构数据。

这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位，代表当前这个常量属于哪种类型。

这14种常量类型各自均有自己的结构。

### 访问标志

在常量池结束之后，紧接着的两个字节表示访问标志，这个标志用于**识别一些类或者接口层次的访问信息**，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类，是否被声明为final等。

访问标志种一共由16个标志位有使用，当前是定义了其中8个。

| 访问标志       | 标志值 | 含义                                        |
| -------------- | ------ | ------------------------------------------- |
| ACC_PUBLIC     | 0x0001 | 是否为public类型                            |
| ACC_FINAL      | 0x0010 | 是否声明为final类型                         |
| ACC_SUPER      | 0x0020 | 是否允许使用invokespecial字节码指令的新语意 |
| ACC_INTERFACE  | 0x0200 | 标识这是一个接口                            |
| ACC_ABSTRACT   | 0x0400 | 是否为abstract类型                          |
| ACC_SYNTHETIC  | 0x1000 | 标识这个类并非用户代码产生的                |
| ACC_ANNOTATION | 0x2000 | 标识这是一个注解                            |
| ACC_ENUM       | 0x4000 | 标识这是一个枚举                            |



### 类索引、父类索引与接口索引集合

类索引和父类索引都是一个u2类型的数据，而接口类型是**一组**u2类型的数据的集合。类索引用于确定这个类的全限定类名，父类索引用于确定这个类的父类的全限定名。接口索引集合用来描述这个类实现了哪些接口。

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后。接口类型集合，入口的第一项——u2类型的数据为接口计数器，表示索引表的容量。

### 字段表集合

字段表开始之前，会有一个u2类型的数据为容量计数器，用来表示这个类共有多少条字段表数据。

字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，**但不包括方法内部声明的局部变量。**

**字段表结构**

| 类型           | 名称             | 数量             |
| -------------- | ---------------- | ---------------- |
| u2             | access_flags     | 1                |
| u2             | name_index       | 1                |
| u2             | descripor_index  | 1                |
| u2             | attributes_count | 1                |
| attribute_info | attributes       | attributes_count |

access_flags项目中存放的是字段修饰符。

| 标志名称      | 标志值 | 含义                     |
| ------------- | ------ | ------------------------ |
| ACC_PUBLIC    | 0x0001 | 字段是否为public         |
| ACC_PRIVATE   | 0x0002 | 字段是否为private        |
| ACC_PROTECTED | 0x0004 | 字段是否为protected      |
| ACC_STATIC    | 0x0008 | 字段是否为static         |
| ACC_FINAL     | 0x0010 | 字段是否为final          |
| ACC_VOLATILE  | 0x0040 | 字段是否为volatile       |
| ACC_TRANSIENT | 0x0080 | 字段是否为transient      |
| ACC_SYNTHETIC | 0x1000 | 字段是否有编译器自动产生 |
| ACC_ENUM      | 0x4000 | 字段是否enum             |

name_index和descriptor_index都是对常量池的引用，分别代表字段的简单名称以及字段和方法的描述符。

简单名称，没有类型和参数修饰的方法或字段名称。

字段和方法的描述符，描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。

**描述符标识字符含义**

| 标识字符 |      含义      | 标识字符 |             含义              |
| :------: | :------------: | :------: | :---------------------------: |
|    B     |  基本类型byte  |    J     |         基本类型long          |
|    C     |  基本类型char  |    S     |         基本类型short         |
|    D     | 基本类型double |    Z     |        基本类型boolean        |
|    F     | 基本类型float  |    V     |         特殊类型void          |
|    I     |  基本类型int   |    L     | 对象类型，如Ljava/lang/Object |

对于数组类型，每一维度将使用一个前置的`[`字符来描述，如定义一个`java.lang.String[][]`，将被描述为`[[java/lang/String`。

用描述符来描述方法时，按照先参数列表，后返回值的顺序描述。参数列表按照参数的严格顺序放在一组小括号`()`之内。如方法`void inc()`描述为`()V`，方法`java.lang.String toString(Int num)`描述为`(I)Ljava/lang/String`。

字段表集合中不会列出从父类继承而来的字段，但有可能列出原本Java代码不存在，由虚拟机自动生成的字段。

在Java语言中，字段是无法重载的，不管字段的描述符是否相同，字段名必须不同。但在字节码中，如果字段的描述符不同，它的名称可以是相同的。

### 方法表集合

方法表入口的第一个u2类型的数据为计数器容量，表明共有几个方法表。

Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构和字段表一致。依次包括了访问标志、名称索引、描述符索引、属性表集合。

**方法访问标志**

| 标志名称         | 标志值 | 含义                           |
| ---------------- | ------ | ------------------------------ |
| ACC_PUBLIC       | 0x0001 | 方法是否为public               |
| ACC_PRIVATE      | 0x0002 | 方法是否为private              |
| ACC_PROTECTED    | 0x0004 | 方法是否为protected            |
| ACC_STATIC       | 0x0008 | 方法是否为static               |
| ACC_FINAL        | 0x0010 | 方法是否为final                |
| ACC_SYNCHRONIZED | 0x0020 | 方法是否为synchronized         |
| ACC_BRIDGE       | 0x0040 | 方法是否由编译器产生的桥接方法 |
| ACC_VARAGES      | 0x0080 | 方法是否接受不定参数           |
| ACC_NATIVE       | 0x0100 | 方法是否为native               |
| ACC_ABSTRACT     | 0x0400 | 方法是否为abstract             |
| ACC_STRICTFP     | 0x0800 | 方法是否为strictfp             |
| ACC_SYNTHETIC    | 0x1000 | 方法是否由编译器自动产生       |

在Java代码中，要重载一个方法，除了要与原方法具有相同的简单名称以外，还要求必须拥有一个与原方法不同的特征签名，所谓特征前面，就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是说返回值不会包含在特征签名中。

但Class文件中，只要描述符不完全相同的两个方法就可以共存。也就是说，简单名称和特征签名相同的两个方法，如果返回值不同，也可以在Class文件中共存。

### 属性表集合

在Class文件、字段表、方法表都可以携带自己的属性表集合。

与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，不再要求各个属性表具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表写入自己定义的属性信息。

为了能正确解析Class文件，Java虚拟机预定义了21项属性（参照Java虚拟机规范Java SE 7版）。

**属性表的结构**

| 类型 |         名称         |       数量       |
| :--: | :------------------: | :--------------: |
|  u2  | attribute_name_index |        1         |
|  u4  |   attribute_length   |        1         |
|  u1  |         info         | attribute_length |

> Code属性

Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。

**Code属性表结构**

| 类型           | 名称                   | 数量                   |
| -------------- | ---------------------- | ---------------------- |
| u2             | attribute_name_index   | 1                      |
| u4             | attribute_length       | 1                      |
| u2             | max_stack              | 1                      |
| u2             | max_locals             | 1                      |
| u4             | code_length            | 1                      |
| u1             | code                   | code_length            |
| u2             | exception_table_length | 1                      |
| exception_info | exception_table        | exception_table_length |
| u2             | attributes_count       | 1                      |
| attribute_info | attributes             | attributes_count       |

attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为`Code`。

attrbute_length表示属性值长度，因为属性表名称和属性表长度固定6字节，所以属性值长度为属性表长度减6。

max_stack代表了操作数栈的最大深度。虚拟机运行时需要根据这个数值去分配栈帧。

max_locals表示局部变量表所需空间，单位为slot。

code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码的长度。code是用于存储字节码指令的一系列字节流。

exception_table_length，显式异常处理表集合。

**异常处理表结构**

| 类型 | 名称     | 数量 | 类型 | 名称       | 数量 |
| ---- | -------- | ---- | ---- | ---------- | ---- |
| u2   | start_pc | 1    | u2   | handler_pc | 1    |
| u2   | end_pc   | 1    | u2   | catch_type | 1    |

start_pc和end_pc表示，字节码的范围（不包括end_pc），如果在这个范围内，发生了catch_type中的异常或其子类异常，就会跳转到handler_pc，执行其指向的字节码。

> Exception属性

...

## 字节码指令简介

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为**操作码**）以及跟随其后的零至多个代表此操作所需参数（称为**操作数**）而构成。由于Java虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操数，只有操作码。

### 字节码与数据类型

对于大多数与数据类型相关的字节码指令，它们的操作码助记符都有特殊的字符来表示专门为哪种数据进行服务。

由于Java虚拟机的操作码长度只有一个字节，如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型，那么指令的数量恐怕会超出一个字节所能表示的范围了。因此，Java虚拟机的指令集对于特定的操作只提供有限的类型相关指令去支持它，也就是说，指令集将会被故意设计出非完全独立的。一个指令能够兼容多种数据类型的相同操作。

例如，大多数指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean，编译器会在编译期或运行期，将byte和shrot类型的数据带符号扩展为相应的int类型，将boolean和char类型数据零位扩展为相应的int类型数据。也就是说，对byte、short、boolean和char类型的数据的操作，实际上都是使用int数据的操作码。

...



