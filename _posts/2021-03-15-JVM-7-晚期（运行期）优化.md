---
layout:     post
title:      "JVM-晚期（运行期）优化"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# 晚期（运行期）优化

在部分商用虚拟机中，Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，虚拟机会在运行时把这些代码编译成本地机器码，并进行各种层次的优化。完成这个任务的编译器，称为即时编译器（JIT编译器）。

## HotSpot虚拟机内的即时编译器

### 解释器和编译器

许多主流的虚拟机都同时包含解释器和编译器，解释器和编译器两者各有优势。

当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获取更高的执行效率。

当程序运行环境中内存资源限制较大时，可以使用解释器执行节约内存，反之可以使用编译器提高效率。

同时，解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提示运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行。

HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器。现在主流的HotSpot虚拟机，默认采用解释器和其中一个编译器直接配合的方式工作。

由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，对解释执行的速度也有影响，为了在程序启动响应时间与运行效率之间达到最佳平衡，HotSpot虚拟机会逐渐启用分层编译。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次：

- 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译。
- 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。
- 第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

### 编译对象和触发条件

上文提及的**热点代码**有两类：

- 被多次调用的方法
- 被多次执行的循环体

那么如何判定一段代码是否是热点代码，目前主流的热点探测判定方式主要有两种，分别如下：

- 基于采样的热点探测
- 基于计数器的热点探测

在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：方法调用计数器和回边计数器。

当一个方法被调用的时候，会先检查是否存在本地编译的版本，如果没有则将它的计数器加1，判断方法调用计数器和回边计数器的和是否超过阈值，如果超过阈值则提交该方法的代码编译请求。

方法调用计数器默认统计的不是方法被调用的绝对次数，而是一个相对的执行效率，即**一段时间之内方法被调用的次数**。当超过一定的时间限制，如果方法的调用次数仍然不足以让它提交给即时编译器，那么这个方法的调用计数器就会被减少一半，这个过程被称为**方法调用计数器热度的衰减**。而这段时间就称为此方法统计的**半衰周期**。

回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。与方法计数器不同的是，回边计数器没有计数衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。

### 编译过程

在后台执行编译的过程中，Server Compiler和Cilent Compiler两个编译器的编译过程是不一样的。

对于Client Compiler来说，它是一个简单快速的三段式编译器，主要关注点在于局部的优化，而放弃了很多耗时较长的全局优化手段。

而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器。它会执行所有经典的优化动作，还会实施一些与Java语言特性密切相关的优化技术，另外还可能会根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化。