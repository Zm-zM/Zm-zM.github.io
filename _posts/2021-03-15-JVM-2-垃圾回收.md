---
layout:     post
title:      "JVM-Java垃圾回收"
subtitle:   " \"基础内容\""
date:       2021-03-15 12:00:00
author:     "Zm"
header-img: "img/post-bg-2020.jpg"
tags:
    - JVM
---

# 对象存活判定算法

## 引用计数算法

给对象添加一个引用计数器，每当一个地方引用它时，计数器加一，当引用失效时，计数器减一，计数器在任何时刻都为0的对象，就是垃圾对象。

但是引用计数算法，无法解决对象之间相互循环引用的情况。

## 可达性分析算法

通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明该对象是不可用的。

在Java语言中，可以作为GC Roots对象的有以下几列：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即Native方法）引用的对象

## 回收的过程

要宣告一个对象死亡，至少要经过两次标记过程。

如果对象没有与GC Roots相连的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法，当对象没有覆盖`finalized()`方法，或者该方法已经被调用过了。虚拟机将视为“没有必要执行”。

如果该对象被判定为“有必要执行”，它就会被放入一个叫做`F-Queue`的队列中，并在稍后由一个虚拟机自动建立的、低优先级的`Finalizer`线程去执行它。

`finalized()`方法是对象逃脱死亡的最后一次机会，如果对象要在`finalized()`方法中拯救自己——只要重新与引用链中的任何一个对象建立关联即可。那么它将在第二次标记时，被移除处“即将回收”集合。

任何对象的`finalized()`方法都只会被系统自动调用一次。

## 回收方法区

方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。

> 判断废弃常量

没有任何地方引用了这个常量

> 判断无用的类

- 该类的所有实例都已经被回收。
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

无用的类不一定像对象一样，不用了就必然会回收。是否回收需要设置一些参数控制

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以确保永久代不会溢出。

# 垃圾收集算法

## 标记—清除算法（Mark-Sweep）

算法分为“标记”和“清除”两个阶段。首先标记出所有要回收的对象，在标记完成后，统一回收所有要标记的对象。

> 不足之处

效率问题，标记和清除两个过程的效率都不高。

空间问题，标记清除之后，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个垃圾收集动作。

## 复制算法

将可用容量划分为大小相同的两块，每次只使用其中的一块，当这一块内存使用完了，就将还使用的对象复制到另一块内存上，任何将已使用的这块内存一次清理掉。

实现简单，运行高效，只是占用的空间较大。

## 标记—整理算法

标记过程和“标记—清除”算法一样，但后续步骤是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

# 垃圾收集器

## Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器。

这个收集器是单线程的收集器，不仅仅是只有使用一个CPU或一个收集线程去完成垃圾收集，更重要的是它在进行垃圾收集时，必须暂停所有的工作线程。

它优于其他收集器的地方是，简单而高效，没有线程交互的开销。

## ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集以外，其他和Serial收集器几乎完全相同。

除了Serial收集器，只有它能和CMS收集器配合使用。

在单Cpu及双Cpu情况下，表现不一定比Serial要好，但随着Cpu数量的增加，它对系统资源的有效利用还是比较好的。

## Parallel Scavenge收集器

Parallel Scavenge收集器是一个新生代收集器，也是使用复制算法的并行的多线程收集器，这一点与ParNew收集器相同。

与ParNew收集器不同的是，Parallel Scavenge收集器的关注点在于达到一个可控制的吞吐量。所谓吞吐量就是Cpu用于运行用户代码的时间与Cpu消耗时间的比值。而CMS等收集器的关注点在于尽可能地缩短垃圾收集时用户线程的停顿时间。

停顿时间越短就越适合需要**与用户交互的程序**，良好的相应速度能提示用户体验，而高吞吐量则可以高效率地利用Cpu时间，尽快完成程序的运算任务，主要适合在**后台运算而不需要太多交互**的任务。

## Serial Old收集器

Serial Old收集器的老年代版本，它同样是一个单线程收集器，使用“标记—整理”算法。

## Parallel Old收集器

Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记—整理”算法。

## CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

它的运行过程包括4个步骤，初始标记、并发标记、重新标记和并发清除。

**初始标记**仅仅只是标记以下`GC Roots`能直接关联到的对象，速度很快。**并发标记**阶段就是进行`GC Roots Tracing`的过程，而**重新标记**阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

整个过程中，耗时最长的**并发标记**和**并发清除**过程都可以和用户线程一起工作。

> 缺点

CMS收集器对Cpu资源非常敏感。

CMS收集器无法处理浮动垃圾（Floating Garbage）

CMS收集器是基于“标记—清除”算法，可能会导致空间碎片过多。

## G1收集器

G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。